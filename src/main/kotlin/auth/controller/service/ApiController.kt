package auth.controller.service

import auth.model.service.Service
import auth.service.TokenService
import auth.util.helper.Properties
import auth.util.helper.SignatureAuthenticator
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.CrossOrigin
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RestController
import java.io.File

@RestController("serviceRestController")
@CrossOrigin
class ApiController {
    private val logger = LoggerFactory.getLogger(ApiController::class.java)

    @Autowired
    lateinit var tokenService: TokenService

    @Autowired
    lateinit var signatureAuthenticator: SignatureAuthenticator

    @Autowired
    lateinit var properties: Properties

    internal val services by lazy {
        val services: MutableList<Service> = mutableListOf()
        val mapper = ObjectMapper(YAMLFactory())
        val serviceConfigFiles = File(properties.service.servicesFolderPath).listFiles()
        serviceConfigFiles.forEach {
            try {
                if (it.isFile()) {
                    val service = mapper.readValue(it, Service::class.java)
                    services.add(service)
                }
            } catch (e: Exception) {
                logger.error("Unable to read service config file: {}", it.name)
            }
        }
        services.toList()
    }

    internal fun getService(serviceId: String): Service {
        val service = this.services.find { it.guid == serviceId }

        if (service == null) {
            throw ServiceNotFoundException("Service with id $serviceId not found")
        }
        return service
    }

    // Session id is a random string generated by requesting user that is part of the signature
    @GetMapping("{issuer}/login")
    fun token(
        @RequestHeader(value = "username") serviceId: String,
        @RequestHeader(value = "signature") signature: String,
        @RequestHeader(value = "nonce") nonce: String,
        @PathVariable issuer: String
    ): ResponseEntity<Any> {
        val body = HashMap<String, Any?>()
        val service: Service

        try {
            service = getService(serviceId)

            val isValidNonce = signatureAuthenticator.verifyNonce(nonce)
            val isValidSignature = signatureAuthenticator.verifyService(nonce, signature, service)

            if (!isValidNonce || !isValidSignature) {
                body.put("error", "invalid service identifier")
                return ResponseEntity<Any>(body, HttpStatus.UNAUTHORIZED)
            }
        } catch (e: Exception) {
            body.put("error", e.message)
            return ResponseEntity<Any>(body, HttpStatus.BAD_REQUEST)
        }

        return ResponseEntity<Any>(tokenService.build(issuer, service.payload), HttpStatus.OK)
    }
}

class ServiceNotFoundException(message: String) : Exception(message)
